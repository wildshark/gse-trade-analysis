<?php
/**
 * public/api.php
 *
 * JSON API for the Trade Analysis tool.
 * - Returns KPIs, daily aggregates, top symbols, sector breakdown
 * - Generates Buy / Sell suggestions using liquidity, momentum, consistency and price-change heuristics
 *
 * Query params:
 *   - start=YYYY-MM-DD
 *   - end=YYYY-MM-DD
 *   - symbol=MTNGH
 *   - sector=ICT
 *
 * Response:
 * {
 *   kpis: {...},
 *   daily: [...],
 *   topVol: [...],
 *   topVal: [...],
 *   sector: [...],
 *   signals: {
 *     buy: [...],
 *     sell: [...],
 *     meta: {...}
 *   }
 * }
 */

declare(strict_types=1);

// Basic headers
header('Content-Type: application/json; charset=utf-8');
// If you need CORS for local testing, uncomment the next line:
// header('Access-Control-Allow-Origin: *');

try {
  // Connect to SQLite
  $dbPath = dirname(__DIR__) . '/storage/trades.db';
  if (!file_exists($dbPath)) {
    // Return a graceful message if DB doesn't exist yet
    echo json_encode([
      'error' => 'Database not found. Please upload a CSV first.',
      'hint'  => 'Use the upload form on index.php to ingest your dataset.'
    ]);
    exit;
  }

  $db = new PDO("sqlite:" . $dbPath, null, null, [
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
  ]);

  // Read query parameters
  $params = [
    'start'  => isset($_GET['start'])  ? trim($_GET['start'])  : null,
    'end'    => isset($_GET['end'])    ? trim($_GET['end'])    : null,
    'symbol' => isset($_GET['symbol']) ? strtoupper(trim($_GET['symbol'])) : null,
    'sector' => isset($_GET['sector']) ? strtoupper(trim($_GET['sector'])) : null,
  ];

  // Build WHERE clause
  $where = [];
  $bind  = [];

  // Validate dates (basic)
  if ($params['start'] && !preg_match('/^\d{4}-\d{2}-\d{2}$/', $params['start'])) {
    throw new InvalidArgumentException('Invalid start date format. Use YYYY-MM-DD.');
  }
  if ($params['end'] && !preg_match('/^\d{4}-\d{2}-\d{2}$/', $params['end'])) {
    throw new InvalidArgumentException('Invalid end date format. Use YYYY-MM-DD.');
  }

  if ($params['start']) { $where[] = "trade_date >= :start";  $bind[':start']  = $params['start']; }
  if ($params['end'])   { $where[] = "trade_date <= :end";    $bind[':end']    = $params['end']; }
  if ($params['symbol']){ $where[] = "symbol = :symbol";      $bind[':symbol'] = $params['symbol']; }
  if ($params['sector']){ $where[] = "sector = :sector";      $bind[':sector'] = $params['sector']; }

  $wsql = $where ? ('WHERE ' . implode(' AND ', $where)) : '';
  // For appending conditions safely (e.g., "AND symbol = ...") use the base form:
  $wsqlBase = $wsql ? $wsql : 'WHERE 1=1';

  // Helper functions
  $qAll = function(string $sql, array $bind) use ($db) {
    $st = $db->prepare($sql);
    $st->execute($bind);
    return $st->fetchAll();
  };
  $qOne = function(string $sql, array $bind) use ($db) {
    $st = $db->prepare($sql);
    $st->execute($bind);
    $row = $st->fetch();
    return $row ?: [];
  };

  // KPIs
  $kpis = $qOne("
    SELECT
      COALESCE(SUM(volume),0) AS total_volume,
      COALESCE(SUM(value),0)  AS total_value,
      COUNT(DISTINCT trade_date) AS trading_days,
      COUNT(DISTINCT symbol) AS distinct_symbols
    FROM trades $wsql
  ", $bind);

  // Daily aggregates
  $daily = $qAll("
    SELECT trade_date,
           COALESCE(SUM(volume),0) AS volume,
           COALESCE(SUM(value),0)  AS value
    FROM trades $wsql
    GROUP BY trade_date
    ORDER BY trade_date ASC
  ", $bind);

  // Top symbols by volume/value
  $topVol = $qAll("
    SELECT symbol, COALESCE(SUM(volume),0) AS volume
    FROM trades $wsql
    GROUP BY symbol
    ORDER BY volume DESC
    LIMIT 10
  ", $bind);

  $topVal = $qAll("
    SELECT symbol, COALESCE(SUM(value),0) AS value
    FROM trades $wsql
    GROUP BY symbol
    ORDER BY value DESC
    LIMIT 10
  ", $bind);

  // Sector breakdown
  $sector = $qAll("
    SELECT COALESCE(sector,'(UNKNOWN)') AS sector,
           COALESCE(SUM(volume),0) AS volume,
           COALESCE(SUM(value),0)  AS value
    FROM trades $wsql
    GROUP BY sector
    ORDER BY value DESC
  ", $bind);

  // Signal computation (Buy / Sell)
  // Determine period bounds (based on filtered data)
  $bounds = $qOne("SELECT MIN(trade_date) AS min_d, MAX(trade_date) AS max_d FROM trades $wsql", $bind);
  $periodStart = $params['start'] ?: ($bounds['min_d'] ?? null);
  $periodEnd   = $params['end']   ?: ($bounds['max_d'] ?? null);

  // Count period days
  $periodDaysRow = $qOne("SELECT COUNT(DISTINCT trade_date) AS days FROM trades $wsql", $bind);
  $periodDays = intval($periodDaysRow['days'] ?? 0);

  // Windows: last 30 and last 5 trading days within the filtered set
  $window30 = $qOne("
    WITH d AS (
      SELECT DISTINCT trade_date FROM trades $wsql ORDER BY trade_date
    ),
    r AS (
      SELECT trade_date,
             ROW_NUMBER() OVER (ORDER BY trade_date DESC) AS rn
      FROM d
    )
    SELECT COALESCE(MAX(trade_date),'') AS end_d,
           COALESCE(MIN(trade_date),'') AS start_d
    FROM r
    WHERE rn <= 30
  ", $bind);

  $window5 = $qOne("
    WITH d AS (
      SELECT DISTINCT trade_date FROM trades $wsql ORDER BY trade_date
    ),
    r AS (
      SELECT trade_date,
             ROW_NUMBER() OVER (ORDER BY trade_date DESC) AS rn
      FROM d
    )
    SELECT COALESCE(MAX(trade_date),'') AS end_d,
           COALESCE(MIN(trade_date),'') AS start_d
    FROM r
    WHERE rn <= 5
  ", $bind);

  // Aggregate per symbol for the period
  $perSymbol = $qAll("
    SELECT symbol,
           COUNT(DISTINCT trade_date) AS traded_days,
           COALESCE(SUM(value),0)     AS total_value,
           COALESCE(SUM(volume),0)    AS total_volume,
           COALESCE(AVG(price),NULL)  AS avg_price,
           COALESCE(MAX(value),0)     AS max_day_value
    FROM trades $wsql
    GROUP BY symbol
  ", $bind);

  // Helper: window average daily value per symbol
  $windowAvgValue = function(string $symbol, string $ws, string $we) use ($db, $bind, $wsqlBase) {
    if ($ws === '' || $we === '') return 0.0;
    $sql = "
      SELECT COALESCE(AVG(v),0) AS avg_v
      FROM (
        SELECT trade_date, COALESCE(SUM(value),0) AS v
        FROM trades $wsqlBase AND symbol = :sym AND trade_date >= :ws AND trade_date <= :we
        GROUP BY trade_date
      ) x
    ";
    $st = $db->prepare($sql);
    $loc = $bind;
    $loc[':sym'] = strtoupper($symbol);
    $loc[':ws']  = $ws;
    $loc[':we']  = $we;
    $st->execute($loc);
    $r = $st->fetch();
    return floatval($r['avg_v'] ?? 0);
  };

  // Helper: price change percentage for the period (first vs last price)
  $priceChangePct = function(string $symbol) use ($db, $bind, $wsqlBase) {
    $st1 = $db->prepare("SELECT price FROM trades $wsqlBase AND symbol = :sym AND price IS NOT NULL ORDER BY trade_date ASC  LIMIT 1");
    $st2 = $db->prepare("SELECT price FROM trades $wsqlBase AND symbol = :sym AND price IS NOT NULL ORDER BY trade_date DESC LIMIT 1");
    $loc = $bind; $loc[':sym'] = strtoupper($symbol);
    $st1->execute($loc); $st2->execute($loc);
    $p0 = $st1->fetchColumn(); $p1 = $st2->fetchColumn();
    if ($p0 === false || $p1 === false || !is_numeric($p0) || !is_numeric($p1) || floatval($p0) == 0.0) return null;
    return floatval(($p1 - $p0) / $p0 * 100.0);
  };

  // Thresholds (adjust to your dataset scale)
  $THRESHOLDS = [
    'liq_avg_value'    => 100000.0, // avg daily value considered liquid
    'low_avg_value'    => 10000.0,  // avg daily value considered illiquid
    'mom_up_ratio'     => 1.30,     // last-5 / last-30 >= 1.3 => positive momentum
    'mom_down_ratio'   => 0.70,     // last-5 / last-30 <= 0.7 => negative momentum
    'price_up_pct'     => 5.0,      // price change >= +5% (if price available)
    'price_down_pct'   => -5.0,     // price change <= -5%
    'consistency_frac' => 0.60,     // traded on 60%+ of period days
    'pump_share'       => 0.60,     // one-day value >= 60% of total => pump-like
  ];

  $buy  = [];
  $sell = [];

  if ($periodDays > 0) {
    foreach ($perSymbol as $row) {
      $sym = $row['symbol'];

      $totalValue  = floatval($row['total_value'] ?? 0);
      $avgDailyVal = $periodDays > 0 ? ($totalValue / $periodDays) : 0.0;

      $tradedDays  = intval($row['traded_days'] ?? 0);
      $consistency = $periodDays > 0 ? ($tradedDays / $periodDays) : 0.0;

      $v5  = $windowAvgValue($sym, $window5['start_d'] ?? '',  $window5['end_d'] ?? '');
      $v30 = $windowAvgValue($sym, $window30['start_d'] ?? '', $window30['end_d'] ?? '');
      if ($v30 <= 0) {
        // Fallback to period average to avoid divide-by-zero
        $v30 = max($avgDailyVal, 1.0);
      }
      $momRatio = $v30 > 0 ? ($v5 / $v30) : 0.0;

      $pchg = $priceChangePct($sym); // may be null

      $maxDayVal = floatval($row['max_day_value'] ?? 0);
      $pumpShare = $totalValue > 0 ? ($maxDayVal / $totalValue) : 0.0;

      // BUY signal checks
      $buyChecks = [
        'liquidity'   => ($avgDailyVal >= $THRESHOLDS['liq_avg_value']),
        'momentum'    => ($momRatio     >= $THRESHOLDS['mom_up_ratio']),
        'consistency' => ($consistency  >= $THRESHOLDS['consistency_frac']),
        'price_up'    => (is_numeric($pchg) ? ($pchg >= $THRESHOLDS['price_up_pct']) : true), // if price unavailable, don't block
      ];
      if ($buyChecks['liquidity'] && $buyChecks['momentum'] && $buyChecks['consistency'] && $buyChecks['price_up']) {
        $buy[] = [
          'symbol'           => $sym,
          'avg_daily_value'  => round($avgDailyVal, 2),
          'mom_ratio'        => round($momRatio, 2),
          'traded_days'      => $tradedDays,
          'period_days'      => $periodDays,
          'price_change_pct' => is_numeric($pchg) ? round($pchg, 2) : null,
          'reason'           => 'Liquid + positive momentum + consistent trading' . (is_numeric($pchg) ? ' + price up' : ''),
        ];
      }

      // SELL / AVOID checks
      $sellChecks = [
        'illiquid'     => ($avgDailyVal < $THRESHOLDS['low_avg_value']),
        'neg_momentum' => ($momRatio     <= $THRESHOLDS['mom_down_ratio']),
        'price_down'   => (is_numeric($pchg) ? ($pchg <= $THRESHOLDS['price_down_pct']) : false),
        'pump_risk'    => ($pumpShare    >= $THRESHOLDS['pump_share']),
      ];
      if ($sellChecks['illiquid'] || $sellChecks['neg_momentum'] || $sellChecks['price_down'] || $sellChecks['pump_risk']) {
        $reasons = [];
        if ($sellChecks['illiquid'])     $reasons[] = 'Illiquid';
        if ($sellChecks['neg_momentum']) $reasons[] = 'Negative momentum';
        if ($sellChecks['price_down'])   $reasons[] = 'Price down';
        if ($sellChecks['pump_risk'])    $reasons[] = 'Pump-like concentration';

        $sell[] = [
          'symbol'           => $sym,
          'avg_daily_value'  => round($avgDailyVal, 2),
          'mom_ratio'        => round($momRatio, 2),
          'traded_days'      => $tradedDays,
          'period_days'      => $periodDays,
          'price_change_pct' => is_numeric($pchg) ? round($pchg, 2) : null,
          'pump_share'       => round($pumpShare, 2),
          'reason'           => implode(' + ', $reasons),
        ];
      }
    }

    // Rank results
    usort($buy, function($a, $b) {
      // Prioritize momentum then liquidity
      return ($b['mom_ratio'] <=> $a['mom_ratio']) ?: ($b['avg_daily_value'] <=> $a['avg_daily_value']);
    });
    usort($sell, function($a, $b) {
      // Prioritize pump risk, then illiquidity
      return ($b['pump_share'] <=> $a['pump_share']) ?: ($a['avg_daily_value'] <=> $b['avg_daily_value']);
    });
  }

  // Output
  echo json_encode([
    'kpis'   => $kpis,
    'daily'  => $daily,
    'topVol' => $topVol,
    'topVal' => $topVal,
    'sector' => $sector,
    'signals'=> [
      'buy'  => array_slice($buy,  0, 10),
      'sell' => array_slice($sell, 0, 10),
      'meta' => [
        'period_start' => $periodStart,
        'period_end'   => $periodEnd,
        'windows'      => ['last5' => $window5, 'last30' => $window30],
        'thresholds'   => $THRESHOLDS,
      ],
    ],
  ], JSON_UNESCAPED_UNICODE);

} catch (Throwable $e) {
  http_response_code(500);
  echo json_encode([
    'error'   => 'Internal server error',
    'message' => $e->getMessage(),
  ]);
}
